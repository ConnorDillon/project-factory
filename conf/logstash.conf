input {
  file {
    path => "/Users/connor/Development/rust/project-factory/dev/input"
    codec => json
  }
}

filter {
  if [plugin] == "pecmd" {
    date {
      match => ["[data][PreviousRun5]", "ISO8601"]
      target => "[data][PreviousRun5]"
    }
    date {
      match => ["[data][PreviousRun4]", "ISO8601"]
      target => "[data][PreviousRun4]"
    }
    date {
      match => ["[data][PreviousRun3]", "ISO8601"]
      target => "[data][PreviousRun3]"
    }
    date {
      match => ["[data][PreviousRun2]", "ISO8601"]
      target => "[data][PreviousRun2]"
    }
    date {
      match => ["[data][PreviousRun1]", "ISO8601"]
      target => "[data][PreviousRun1]"
    }
    date {
      match => ["[data][PreviousRun0]", "ISO8601"]
      target => "[data][PreviousRun0]"
    }
    date {
      match => ["[data][LastRun]", "ISO8601"]
      target => "[data][LastRun]"
    }
    mutate {
      rename => {
        "[data][RunCount]" => "[prefetch][run_count]"
        "[data][ExecutableName]" => "[prefetch][executable_name]"
        "[data][Hash]" => "[prefetch][hash]"
        "[data][Version]" => "[prefetch][version]"
        "[data][LastRun]" => "[prefetch][runs]"
        "[data][Volume0Created]" => "[volume][created]"
        "[data][Volume0Name]" => "[volume][name]"
        "[data][Volume0Serial]" => "[volume][serial]"
        "[data][Directories]" => "[prefetch][directories]"
        "[data][FilesLoaded]" => "[prefetch][files_loaded]"
        "path" => "[file][path]"
        "type" => "[file][mime_type]"
      }
      merge => {
        "[data][PreviousRun5]" => "[data][PreviousRun6]"
        "[data][PreviousRun4]" => "[data][PreviousRun5]"
        "[data][PreviousRun3]" => "[data][PreviousRun4]"
        "[data][PreviousRun2]" => "[data][PreviousRun3]"
        "[data][PreviousRun1]" => "[data][PreviousRun2]"
        "[data][PreviousRun0]" => "[data][PreviousRun1]"
        "[prefetch][runs]" => "[data][PreviousRun0]"
      }
      split => {
        "[prefetch][directories]" => ", "
        "[prefetch][files_loaded]" => ", "
      }
      remove_field => ["@timestamp"]
    }
    clone { clones => ["prefetch_event"] }
  }

  if "prefetch_event" in [tags] {
    split { field => "[prefetch][runs]" }
    mutate {
      rename => {
        "[prefetch][runs]" => "@timestamp"
        "[prefetch][executable_name]" => "[file][name]"
        "[file][path]" => "[log][file][path]"
      }
      add_field => {
        "[event][kind]" => "event"
        "[event][category]" => "process"
        "[event][type]" => "start"
        "[event][action]" => "process-start"
        "[event][outcome]" => "success"
      }
      copy => {
        "@timestamp" => "[process][start]"
        "[file][name]" => "[process][name]"
      }
      remove_field => ["volume", "prefetch", "type", "[file][directory]", "[file][mime_type]"]
    }
  }

  if [plugin] == "lecmd" {
    date {
      match => ["[data][TargetAccessed]", "ISO8601"]
      target => "[lnk][target_accessed]"
    }
    date {
      match => ["[data][TargetCreated]", "ISO8601"]
      target => "[lnk][target_created]"
    }
    date {
      match => ["[data][TargetModified]", "ISO8601"]
      target => "[lnk][target_modified]"
    }
    date {
      match => ["[data][TrackerCreatedOn]", "ISO8601"]
      target => "[lnk][tracker_created_on]"
    }
    mutate {
      add_field => { "[file][type]" => "symlink" }
      rename => {
        "[path]" => "[file][path]"
        "[data][LocalPath]" => "[file][target_path]"
        "[data][DriveType]" => "[lnk][drive_type]"
        "[data][ExtraBlocksPresent]" => "[lnk][extra_blocks_present]"
        "[data][FileAttributes]" => "[lnk][file_attributes]"
        "[data][FileSize]" => "[lnk][file_size]"
        "[data][HeaderFlags]" => "[lnk][header_flags]"
        "[data][MACVendor]" => "[lnk][mac_vendor]"
        "[data][MachineID]" => "[lnk][machine_id]"
        "[data][MachineMACAddress]" => "[lnk][machine_mac_address]"
        "[data][RelativePath]" => "[lnk][relative_path]"
        "[data][TargetIDAbsolutePath]" => "[lnk][target_id_absolute_path]"
        "[data][TargetMFTEntryNumber]" => "[lnk][target_mft_entry_number]"
        "[data][TargetMFTSequenceNumber]" => "[lnk][target_mft_sequence_number]"
        "[data][VolumeSerialNumber]" => "[lnk][volume_serial_number]"
      }
    }
    clone { clones => ["lecmd_accessed", "lecmd_created", "lecmd_modified"] }
  }

  if "lecmd_accessed" in [tags] {
    mutate {
      rename => {"[lnk][target_accessed]" => "@timestamp"}
      add_field => {
        "[event][type]" => "access"
        "[event][action]" => "file-accessed"
      }
    }
  }

  if "lecmd_created" in [tags] {
    mutate {
      rename => {"[lnk][target_created]" => "@timestamp"}
      add_field => {
        "[event][type]" => "creation"
        "[event][action]" => "file-created"
      }
    }
  }

  if "lecmd_modified" in [tags] {
    mutate {
      rename => {"[lnk][target_modified]" => "@timestamp"}
      add_field => {
        "[event][type]" => "change"
        "[event][action]" => "file-modified"
      }
    }
  }

  if "lecmd_accessed" in [tags] or "lecmd_created" in [tags] or "lecmd_modified" in [tags] {
    if "FileAttributeDirectory" in [data][FileAttributes] {
      mutate { update => {"[file][type]" => "dir"} }
    } else {
      mutate { update => {"[file][type]" => "file"} }
    }
    mutate {
      rename => {
        "[file][path]" => "[log][file][path]"
      }
      remove_field => [ "lnk", "type" ]
      add_field => {
        "[event][kind]" => "event"
        "[event][category]" => "file"
        "[event][outcome]" => "success"
      }
    }
    mutate { rename => { "[file][target_path]" => "[file][path]" }
    }
  }

  grok {
    match => { "[file][path]" => "(?<[file][directory]>.*)\\(?<[file][name]>.*)" }
  }

  ruby { code => "event.set('[event][created]', Time.now());" }

  mutate { remove_field => ["data", "@version", "plugin", "tags", "host"] }
}

output {
  stdout { }
  # elasticsearch { hosts => ["localhost:9200"] }
  # file {
  #   path => "/Users/connor/Development/rust/project-factory/dev/output"
  #   codec => json
  # }
}
